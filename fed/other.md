## OTHER

### 1. 概念
<a id="bfc">&nbsp;</a>
#### 1.1. 什么是BFC，如果创建BFC？解决什么问题？ <em style="color:red;">*</em>
* 概念：块级格式化上下文，就是一个独立的盒子，并且这个独立盒子的布局(display:属性为block，list-item，table的元素)不受外部影响，也不会影响到外面的元素
* 规则
	* 内部的box会在垂直方向，从顶部开始一个接着一个地放置
	* 同一个BFC中，在两个相邻的块级元素中，垂直margin会发生折叠
	* 每个元素的margin box的左侧，与包含块border box的左侧相接触(对于从左往右的格式化)(即使存在浮动也是)
	* BFC区域不会与float box重叠
	* 计算BFC的高度时，浮动元素也参与
* 触发BFC
	* float属性不为none (如：left|right)
	* overflow的值不为visible(如：hidden|auto|scroll)
	* display属性值为inline-block|flex|inline-flex|table-cell|table-caption
	* position为absolute或fixed
* 解决margin叠加问题
	* 给其中一个div设置display:inline-block属性，触发BFC，它就属于一个独立的BFC了
* 高度塌陷问题
	* 触发父容器parent生成BFC

<a id="synchro">&nbsp;</a>
#### 1.2. 同步和异步的区别？ <em style="color:red;">*</em>
* 同步需要需要等待，异步无需等待
* 区别：
	* 同步：提交请求->等待服务器处理->处理完毕返回 这个期间浏览器不能干别的事。即按顺序执行，执行完一个再执行下一个，需要等待，协调运行
	* 异步：请求通过事件触发->服务器处理(此时浏览器仍然可以做其他事情)->处理完毕。即彼此独立，在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作
* 优缺点：
	* 同步优点：避免出现死锁，读脏数据的发生
	* 同步缺点：同步需要等待资源访问结束，浪费事件，效率低
	* 异步优点：可以提高效率
	* 异步缺点：安全性较低

<a id="amd">&nbsp;</a>
#### 1.3. AMD和CMD规范和区别
* COMMONJS规范：
	* 一个单独的文件就是一个模块，每一个模块都是一个单独的作用域，即在该模块内部定义的变量，无法被其他模块读取，除非定义为`global`对象的属性
* AMD规范：
	* 指 异步模块定义，所有的模块将被异步加载，模块加载不影响后面语句运行，所有依赖某些模块的语句均放置在回调函数中，RequireJs
	* 实现js文件的异步加载，避免网页失去响应
	* 管理模块之间的依赖性，便于代码的编写和维护
* CMD规范：
	* 通用模块定义，明确了模块的基本书写格式和基本交互规则，SeaJs
* 对于依赖模块的加载：
	* AMD是预执行，CMD是懒执行
	* AMD前置依赖，CMD按需加载

#### 1.4. COMMONJS和AMD和CMD规范
* commonjs
	* 定义的模块分为：模块引用(require)/ 模块定义(exports)/ 模块标识(module)
	* 浏览器不兼容commonjs，缺少四个Nodejs环境的变量，为了JS在后端的表现制定的
	* require是同步的，服务端所有模块在本地硬盘，可以同步加载完成，对于浏览器，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于"假死"
	* browserify：供浏览器环境使用的模块打包工具

```
require([module])

var math = require('math');
math.add(2, 3)	// 5
```
* AMD
	* 预执行：尽早地执行(依赖)模块，相当于所有的require都被提前了, 而且模块执行的顺序也不一定100%
	* 异步模块定义。采用异步加载模块，模块的加载不影响后面的语句运行，所有依赖的模块语句，都定义在一个回调函数中，等到加载完成之后，回调函数才会运行
	* requirejs
		* 实现js文件的异步加载，避免网页失去响应
		* 管理模块之间的依赖性，便于代码的编写和维护

```
require([module], callback)
require(['math'], function (math) {
	math.add(2, 3)
})
```

* CMD
	* 按需执行
	* 懒执行：真正需要使用(依赖)模块时才执行该模块，执行模块的顺序也是严格按照模块在代码中出现(require)的顺序

<a id="requirejs">&nbsp;</a>
#### 1.5. requireJS的核心原理是什么？如何动态加载的？如何避免多次加载的？如何 缓存的？ *
* 概念：requireJS是基于AMD模块加载规范的，使用回调函数来解决模块加载的问题。
* 原理：创建script元素，通过指定script元素的src属性来实现加载模块。
* 避免多次加载：将已定义的模块保存在一个对象中，当加载模块依赖的时候，如果在这个对象中存在，则直接返回这个模块。否则再走一遍加载的模块流程
* 特点：
	* 实现js文件的异步加载，避免网页失去响应
	* 管理模块之间的依赖，便于代码的编写和维护
* 项目优化：
	r.js 是基于requirejs模块化的基础上进一步的压缩和打包成一个js，请求数大大减少，便于优化

<a id="http">&nbsp;</a>
#### 1.7. http状态码有那些？分别代表是什么意思？
|状态码|状态|备注|
|:---:|---|:---:|
|100|Continue|继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息|
|200|OK|正常返回信息|
|201|Created|请求成功并且服务器创建了新的资源|
|202|Accepted|服务器已接受请求，但尚未处理|
|301|Moved Permanently|请求的网页已永久移动到新位置|
|302|Found|临时性重定向|
|304|Not Modified|自从上次请求后，请求的网页未修改过|
|400|Bad Request|服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求|
|401|Unauthorized|请求未授权|
|403|Forbidden|禁止访问|
|404|Not Found|找不到如何与 URI 相匹配的资源|
|500|Internal Server Error|最常见的服务器端错误|
|503|Service Unavailable|服务器端暂时无法处理请求（可能是过载或维护）|

<a id="xss">&nbsp;</a>
#### 1.8. 是否了解Web注入攻击，说下原理，最常见的两种攻击（XSS 和 CSRF）了解到什么程度
* Cookie攻击
* 重定向攻击
* XSS: 跨站脚本攻击
	* 攻击者在网页上发布包含攻击性代码的数据，当浏览者看到此网页时，特定的脚本就会以浏览者用户的身份和权限来执行。通过XSS可以比较容易的修改用户数据、窃取用户信息以及造成其他类型的攻击，例如CSRF攻击
* CSRF: 跨站请求伪造
	* 攻击者通过各种方法伪造一个请求，模仿用户提交表单的行为，从而达到修改用户数据，或者执行特定任务的目的
	* 1. post请求
	* 2. 对请求认证

<a id="bower">&nbsp;</a>
#### 1.9. bower和npm区别
* npm是基于nodejs的包管理器，最开始只支持node.js的模块管理，例如yeoman/ grunt/ gulp/ jshint，后来通用到了所有js的包管理工具
* bower专为前端表现设计的包管理器
* npm 支持嵌套式的依赖管理(依赖的软件包还有它自己的依赖)
* bower 只支持扁平的依赖(嵌套依赖由程序员自己解决)
* npm 安装的模块位于项目的根目录下node_modules文件夹内
* bower 下载目录可以自己定义

<a id="https">&nbsp;</a>
#### 1.10. HTTPS
* http：缺少并发，异步机制，安全性
* https：
	* 保证传输链路安全：所有端到端的数据传输都经过加密，且数据内容不可篡改，杜绝了链路上数据被窃取的可能性
	* 实现网址身份认证：只有在访问真正的网址时，浏览器才能正常访问，否则会给出安全提示
	* 证书集中部署：公钥和私钥分离部署，防止私钥泄露，证书集中部署易于管理
	* 防访问被劫持：

<a id="hmr">&nbsp;</a>
#### 1.11. 热替换-HMR
* 原理：在应用程序运行过程中替换、添加或删除模块，无需重新加载整个页面
* 优点：
	* 保留在完全重新加载页面时丢失的应用程序状态
	* 只更新变更内容，以节省宝贵的开发时间
	* 调整样式更加快速

<a id="mongodb">&nbsp;</a>
#### 1.12. MongoDB
* 概念：一种非关系型的数据库
* mongoose是在nodejs环境下操作mongodb的对象模型工具
<img src="https://images2015.cnblogs.com/blog/740839/201707/740839-20170721123112068-7289503.jpg" />

```
Schema：定义数据库的结构
Model：由Schema编译而成的构造器，具有抽象属性和行为，可以对数据库进行增删改查
Document：由Model创建的实例，它的操作也会影响数据库
```

<a id="cdn">&nbsp;</a>
#### 1.13. CDN
* 将静态文件分发到最接近用户的节点，使用户可就近取得所需内容，提高用户访问的响应速度和成功率。解决因分布、带宽、服务器性能带来的访问延迟问题，适用于站点加速、点播、直播等场景

#### 1.14. 防抖和节流
* 防抖：多次执行变成最后一次执行。原理：维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发

```
function debounce(fn, wait) {
  var timeout = null;
  return function() {
    if(timeout !== null)
      clearTimeout(timeout);
    timeout = setTimeout(fn, wait);
  }
}
// 处理函数
function handle() {
  console.log(Math.random());
}
// 滚动事件
window.addEventListener('scroll', debounce(handle, 1000));
```
* 节流：多次执行变成每隔一段时间执行。原理：通过判断是否到达一定时间来触发函数

```
var throttle = function(func, delay) {
	var timer = null;
 	var startTime = Date.now();
 	return function() {
		var curTime = Date.now();
		var remaining = delay - (curTime - startTime);
		var context = this;
		var args = arguments;
		clearTimeout(timer);
    if (remaining <= 0) {
			func.apply(context, args);
			startTime = Date.now();
    } else {
			timer = setTimeout(func, remaining);
    }
	}
}
function handle() {
	console.log(Math.random());
}
window.addEventListener('scroll', throttle(handle, 1000));
```

<a id="reg">&nbsp;</a>
#### 1.5. 正则表达式
* 元字符

|元字符|作用|
|:---:|:---:|
|.|匹配任意字符除了换行符和回车符|
|[]|匹配方括号内的任意字符。比如[0-9]就可以用来匹配任意数字|
|^|^9：代表匹配以9开头。[&#94;9]：代表不匹配方括号内除了9的字符|
|{1,2}|匹配1到2位字符串|
|(yck)|只匹配和yck相同字符串|
|&#124;|匹配&#124;前后任意字符串|
|\|转义|
|*|只匹配出现0次及以上*前的字符|
|+|只匹配出现1次及以上+前的字符|
|?|?之前字符可选|

* 修饰符

|修饰符|作用|
|:---:|:---:|
|i|忽略大小写|
|g|全局搜索|
|m|多行|

* 字符简写

|简写|作用|
|:---:|:---:|
|\w|匹配字母数字或下划线|
|\W|和上面相反|
|\s|匹配任意的空白符|
|\S|和上面相反|
|\b|匹配单词的开始或结束|
|\B|和上面相反|

#### 1.6. Load和DOMContentLoaded区别
* Load：代表页面中的DOM，CSS，JS，图片已经全部加载完毕
* DOMContentLoaded：初始的HTML被完全加载和解析，不需要等待CSS，JS，图片加载。

#### 1.7. 图层
* 一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。
* 不同的图层渲染互不影响，对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。也不能生成过多的图层，会引起反作用
* 通过以下常用属性可以生成新图层
	```
	* 3D 变换：translate3d、translateZ
	* will-change
	* video、iframe 标签
	* 通过动画实现的 opacity 动画转换
	* position: fixed
	```

<a id="repaint">&nbsp;</a>
#### 1.8. 重绘(Repaint)和回流(Reflow)
* 重绘：当节点需要更改外观而不会影响布局的，比如改变`color`
* 回流：布局或者几何属性需要改变
* 回流必定会发生重绘，重绘不一定会引发回流。
* 以下几个动作可能会导致性能问题：

```
* 改变window大小
* 改变字体
* 添加或删除样式
* 文字改变
* 定位或者浮动
* 盒模型
```

* 减少重绘或回流
	* 使用`translate`替代`top`
	* 使用`visibility` 替换`display:none`，因为前者只会引起重绘，后者会引发回流(改变了布局)
	* 不要把DOM结点的属性值放在一个循环里当成循环的变量
	* 不要使用table布局，可能很小的一个小改动会造成整个table的重新布局
	* 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择`requestAnimationFrame`
	* CSS选择器从右往左匹配查找，避免DOM深度过深


<a id="safety"></a>
#### 1.9. 安全
* XSS(跨站脚本)：通过修改HTML节点或者执行JS代码来攻击网站。
	* 防御：最普通的做法是转义输入输出的内容，对于引号，尖括号，斜杠进行转义。对于富文本可以使用白名单
	* 利用用户对指定网站的信任
* CSRF(跨站请求伪造)：利用胡勇的登录态发起恶意请求
	* 防御：遵循以下几种规则
	```
	1. Get请求不修改数据
	2. 不让第三方网站访问到用户Cookie：设置`SameSite`属性
	3. 阻止第三方网站请求接口：验证Referer
	4. 请求是附带验证信息，比如验证码或者token
	```
	* 利用网站对用户网页浏览器的信任
* CSP(内容安全策略)：建立白名单，规定浏览器只能够执行特定来源的代码
	* 通常可以通过HTTP Header 中的 `Content-Security-Policy`来开启CSP
* 密码安全
	* 通常需要对密码加盐，然后进行几次不同加密算法的加密
	```
	# 加盐就是给原密码添加字符串，增加原密码长度
	sha256(sha1(md5(salt+password+salt)))
	```
	* 使用验证码增加延时
	* 限制尝试次数
	* 提示账号或密码错误

### 2. 细节
#### 2.1. 对移动端开发了解多少？
* 响应式设计
* Zepto
* @media
* viewport
* JavaScript正则表达式判断平台

#### 2.2. 移动端最小触控区域是多大？
* 44px*44px
* iphone4: 320*480
* iphone5: 320*568
* iphone6: 375*667
* iphone6plus: 414*736

#### 2.3. 雪碧图
* 将小图标和背景图像合并到一张图片上，然后利用css的背景定位来显示需要显示的图片部分

#### 2.4. html模板语言
* html不支持动态语音
	* 让网站即享受html高效，又享受内容的动态化
	* artTemplate/ mustache/ jquery.tmpl

#### 2.5. Zepto的点透问题如何解决？
* 事件：弹窗点击关闭，会触发按钮下面的内容的点击事件或者链接
* 原因：click事件300ms的延迟
* 解决方法：
	* fastclick
	* 用touchend代替tap事件，并阻止touchend的默认行为
	* 延迟300ms+处理事件

#### 2.6. WEB应用从服务器主动推送Data到客户端有那些方式？
* websocket
* 不可见的iframe
* ajax 长连接

#### 2.7. 如何设计突发大规模并发架构？
* 前端静态化
* 静态资源单独部署(浏览器对于同一个域名的访问限制)
* CDN缓存
* 后端缓存 - json文件缓存或者redis缓存
* 网络请求合并
* 前端削尖 - 减少并发对服务器的压力
* 后端限流 - 超过访问限制，返回友好提示
* 访问量大的活动 - 单独部署
* dns-prefetch预获取

* 主要是利用好 缓存和隔离/ CDN

#### 2.8. 性能优化
* 前端
	* 减少重绘
	* 避免脚本阻塞加载
	* 避免节点深层级嵌套
	* 页面缓存
	* 合并文件压缩
	* HTML+CSS3+Javascript各司其职
	* 图像合并实现CSS Sprites
	* 避免使用iframe
	* 多域名请求
	* 避免空链接属性
	* 使用图像的BASE64编码
	* 显式设置图片的宽高
	* 显式指定文档字符集
	* 渐进式增强设计
	* 懒加载与预加载
	* CND机制
	* HTTP协议的合理使用
	* 动静分离
	* HTTP持久连接
	* GZIP压缩技术

#### 2.9. 单页面性能优化
* 静态资源压缩 - html/ css/ js/ 图片
* 资源合并 - concatjs
* 资源懒加载/ 按需加载 - 图片
* 预加载
* 静态资源 - 单独部署(浏览器对同域并发请求有限制)
* 资源缓存

#### 2.10. 架构工程师
* 代码托管
* 自动化测试
* 性能监控
* 微服务化
* 容灾备份
* 云主机/ 数据库
* 运维部署
* 负载均衡
* 日志统计
* 持续集成
* 代码托管

#### 2.11. 前端架构
* 代码：实现系统架构的HTML、CSS、JavaScript
* 流程：怎样用工具和流程构建一个高效且避免出错的工作流
* 测试：可扩展和可持续优化的系统。新老代码的兼容
* 文档：编写良好的文档

#### 2.12. 性能相关

##### 2.12.1. 网络相关
* DNS预解析：DNS解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的IP

```
<link rel="dns-prefetch" href="http:\/\/baidu.com" />
```
* 缓存：降低资源的重复加载提高网页的整体加载速度
* 预渲染：可以通过预渲染将下载的文件预先在后台渲染
	* 预渲染虽然可以提高页面的加载速度，但是要确保该页面百分之百被用户在之后打开，否则就白白浪费资源

```
<link rel="prerender" href="http:\/\/example.com" />
```

##### 2.12.2. 优化渲染过程
* 懒执行：将某些逻辑延迟到使用时再计算。可以用于首屏优化。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒
* 懒加载：只加载自定义区域(通常是可视区域，也可以是即将进入可视区域)内需要加载的东西

#### 2.12.3. 文件优化
* 图片优化
	* 减少像素点
	* 减少每个像素点能够显示的颜色
* 图片加载优化
	* 尽量用CSS代替小图标
	* 图片用CDN加载，加载裁剪之后的图片，不需要加载原图
	* 将多个图标文件整合到一张图片中(雪碧图)
	* 选择正确的图片格式：
		* 能够显示WebP格式的浏览拿起尽量使用WebP。具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点是兼容性不好
		* 小图标用png，或者字体图标
		* 照片用JPEG
* 其他文件优化
	* CSS文件放在`head`中
	* 服务器开启文件压缩功能
	* 将`script`标签放在`body`底部，因为JS文件执行会阻塞渲染
	* 把`script`标签放在任意位置，然后加上`defer`，表示该文件会并行下载，但是会放到HTML解析完成后顺序执行
	* 对于没有任何依赖的JS文件，可以加上`async`，表示加载和渲染后续文档元素的过程将和JS文件的加载与执行并行无序进行
	* 执行JS代码过长会卡主渲染，对于需要很多时间计算的代码可以考虑用`Webworker`
* CDN：静态资源尽量使用CDN加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个CDN域名

<a id="cache"></a>
#### 2.13. 缓存
* 强缓存：表示在缓存期间不需要请求，`state code`为200。

```
Expires: Wed, 22 Oct 2018 08:41:00 GMT
	// 表示资源会在`Wed, 22 Oct 2018 08:41:00 GMT` 后过期
Cache-Control: max-age=30
	// 表示资源会在30秒后过期，需要再次请求
```
* 协商缓存：如果缓存过期了，可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回304

```
Last-Modified
	// 表示本地文件最后修改日期
If-Modified-Since
	// 将`Last-Modified`的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话将新的资源发送回来
```
	* 如果再本地打开缓存文件，就会造成`Last-Modified`被修改，所以在HTTP/1.1出现了ETag

```
ETag	// 类似于文件指纹
If-None-Match		
	// 会将当前`ETag`发送给服务器，询问该资源`ETag`是否变动，有变动的话就将新的资源发送回来，并且`ETag`优先级比`Last-Modified`高
```

#### 2.14. 使用Webpack优化项目
* 对于Webpack4，打包项目使用production模式，自动开启代码压缩
* 使用ES6模块来开启tree shaking，可以移除没有使用的代码
* 优化图片，对于小图可以使用base64的方式写入文件中
* 按照路由拆分代码，实现按需加载
* 给打包出来的文件名添加哈希，实现浏览器缓存文件
