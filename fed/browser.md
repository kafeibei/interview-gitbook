## 浏览器

#### 1.1 浏览器的标准模式和怪异模式
* 怪异模式：W3C标准出台之前，不同的浏览器在页面的渲染上没有统一的规范，产生了差异，即怪异模式或兼容模式
* 标准模式：W3C标准出台之后，不同浏览器对页面的渲染有了统一的标准，即标准模式或严格模式
* 区别
	* 盒模性的定义
	* 设置行内元素的高宽
		* 标准模式下：span等行内元素设置width和height不会生效，怪异模式：会生效
	* 设置百分比的高度
		* 标准模式下：一个元素的高度是由其包含的内容决定的，如果父元素没有设置高度，子元素设置一个百分比的高度是无效的
	* margin:0 auto设置水平居中，IE下无效
		* 解决方法：用text-align:center属性
	* 怪异模式下：设置图片的padding会失效
	* 怪异模式下：table中的字体属性不能继承上层的设置
	* 怪异模式下：white-space:pre会失效

#### 1.2. css js放置位置和原因
* 网址加载整个完整的过程
	* 浏览器从服务端接收html代码，然后开始解析html
	* 构建DOM树(根据html代码自顶向下进行构建)，并且在同时构建渲染树
	* 遇到js文件加载执行，将阻塞DOM树的构建；遇到CSS文件，将阻塞渲染树的构建

> * script标签中的defer属性：构建DOM树的过程和js文件的加载异步(并行)进行，但是js文件执行需要在DOM数构建完成之后
> * script标签中的async属性：构建DOM树、渲染树的过程和js文件的加载和执行异步(并行)进行

* script标签最好放到```</body>```标签前面，防止网页加载时出现空白情况，持续给用户提供视觉反馈
* css标签放在```<head></head>```标签之间，浏览器边构建边渲染

#### 1.3. 常遇到的浏览器兼容性问题有哪些？常用到的hack技巧
* ie6: _
* ie7: *
* firefox: @-moz
* chrome: @-webkit-

#### 1.4. IE6的bug，和一些定位写法
* 双边距问题
	* 页面元素使用float浮动时，只要该元素带有margin像素都会使该值乘以2。可以在该元素中加入display:inline或display:block明确其元素类型可解决双边距的bug
* IE6中3像素的问题
	* 元素使用float浮动后，元素与相邻的元素之间会产生3px的间隙。需要使布局在同一行的元素都加上float浮动
* IE6图片链接的下方有间隙
	* IE6中图片下方会存在一定的间隙，需要将img标签定义为display:block或定义vertical-align对应的属性。也可以为img对应的样式写入font-size:0
* IE6下空元素的高度bug
	* 如果一个元素没有任何内容，当在样式中为这个元素设置了0~19px之间的高度时。此元素的高度始终为19px
	* overflow:hidden
	* 元素中插入空白符
	* 插入注释
	* font-size:0
* IE6中z-index失效
	* 元素的父级元素设置的z-index为1，那么其子级元素再设置z-index时会失效，其层级会继承父级元素的设置，造成某些层级调整上的BUG  

#### 1.5. 什么是渐进式渲染
* 首先写一段满足所有浏览器的基本样式，然后针对不同高级浏览器编写更漂亮的样式

#### 1.6. 浏览器加载script标签 网站发生的事情

```
1. 拉取HTML页面(index.html)
2. 开始解析HTML
3. 解析到`<script>`标签之后准备获取script文件
4. 浏览器获取script文件。同时html解析中断并且阻断页面上其他html的解析
5. 一段时间后，script下载完成并且执行
6. 继续解析HTML文档的其他部分(解析script之后的html代码)
```

* 任何script代码都能改变HTML的结构，通过`document.write()`这种方式或者其他方式。就导致了HTML解析必须等待script全部被下载和执行完，HTML才能解析script标签之后余下的部分

#### 1.7. 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？

```
1. 浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器(Apache、Tomcat、Node.Js、nignx等)发起请求
2. 服务器交给后端(PHP、JaVa、Python等)处理完成之后返回数据，浏览器接收文件(HTML、JS、CSS、图像等)，同时使用缓存。如果浏览器访问过，缓存上有对应的资源，会与服务器最后修改时间对比，一致则返回304
3. 浏览器对加载到的资源进行语法解析，建立相应的内部数据结构(如HTML的DOM)
4. 载入解析到的资源文件，渲染页面，完成
```

#### 1.8. 浏览器渲染机制

```
1. 处理 HTML 并构建 DOM 树。
2. 处理 CSS 构建 CSSOM 树。
3. 将 DOM 与 CSSOM 合并成一个渲染树。
4. 根据渲染树来布局，计算每个节点的位置。
5. 调用 GPU 绘制，合成图层，显示在屏幕上
```
* 构建CSSOM树时，会阻塞渲染，直至CSSOM树构建完成，所以应该尽量保证层级扁平，减少过渡层叠。
* 当HTML解析script标签时，会暂停构建DOM，完成后才会从暂停的地方重新开始
